//                           jpegModel
// Model JPEG. Return 1 if a JPEG file is detected or else 0.
// Only the baseline and 8 bit extended Huffman coded DCT modes are
// supported.  The model partially decodes the JPEG image to provide
// context for the Huffman coded symbols.
//
enum {SMC=1,APM1,APM2,RCM,SCM,MCM,CM,MX,MC};
char *t;
  // context hash -> bit history
  // As a cache optimization, the context does not include the last 1-2
  // bits of huffcode if the length (huffbits) is not a multiple of 3.
  // The 7 mapped values are for context+{"", 0, 00, 01, 1, 10, 11}.
int tsize;
int c1,c2,c3;
int w4,prm;
int mpw[16]= {4,4,3,2,2,2,1,1,1,1,1,1,0,0,0,0};
int zzu[64]={  // zigzag coef -> u,v
  0,1,0,0,1,2,3,2,1,0,0,1,2,3,4,5,4,3,2,1,0,0,1,2,3,4,5,6,7,6,5,4,
  3,2,1,0,1,2,3,4,5,6,7,7,6,5,4,3,2,3,4,5,6,7,7,6,5,4,5,6,7,7,6,7};
int zzv[64]={
  0,0,1,2,1,0,0,1,2,3,4,3,2,1,0,0,1,2,3,4,5,6,5,4,3,2,1,0,0,1,2,3,
  4,5,6,7,7,6,5,4,3,2,1,2,3,4,5,6,7,7,6,5,4,3,4,5,6,7,7,6,5,6,7,7};

   // State of parser
   int jpeg;  // 1 if JPEG is detected
   int next_jpeg;  // updated with jpeg on next byte boundary
   int app;  // Bytes remaining to skip in APPx or COM field
   int sof, sos, data;  // pointers to buf
   int *ht;  // pointers to Huffman table headers
   int htsize;  // number of pointers in ht

   // Huffman decode state
   int huffcode;  // Current Huffman code including extra bits
   int huffbits;  // Number of valid bits in huffcode
   int huffsize;  // Number of bits without extra bits
   int rs;  // Decoded huffcode without extra bits.  It represents
  // 2 packed 4-bit numbers, r=run of zeros, s=number of extra bits for
  // first nonzero code.  huffcode is complete when rs >= 0.
  // rs is -1 prior to decoding incomplete huffcode.
   int mcupos;  // position in MCU (0-639).  The low 6 bits mark
  // the coefficient in zigzag scan order (0=DC, 1-63=AC).  The high
  // bits mark the block within the MCU, used to select Huffman tables.

   // Decoding tables
   // Tc*64+Th*16+m -> min, max, val
   int *hufmin;
   int *hufmax;
   int *hufval;
   int mcusize;  // number of coefficients in an MCU
  // int linesize; // width of image in MCU
   int *hufsel1; // DC/AC, mcupos/64 -> huf decode table
   int *hufsel2;
   // Image state
   int* color;  // block -> component (0-3)
   int* pred;  // component -> last DC value
   int dc;  // DC value of the current block
   int width;  // Image width in MCU
   int row, column;  // in MCU (column 0 to width-1)
   char* cbuf; // Rotating buffer of coefficients, coded as:
  // DC: level shifted absolute value, low 4 bits discarded, i.e.
  //   [-1023...1024] -> [0...255].
  // AC: as an RS code: a run of R (0-15) zeros followed by an S (0-15)
  //   bit number, or 00 for end of block (in zigzag order).
  //   However if R=0, then the format is ssss11xx where ssss is S,
  //   xx is the first 2 extra bits, and the last 2 bits are 1 (since
  //   this never occurs in a valid RS code).
   int cpos;  // position in cbuf
   //int huff1, huff2, huff3, huff4;  // hashes of last codes
   int rs1;//, rs2, rs3, rs4;  // last 4 RS codes
   int ssum, ssum1, ssum2, ssum3;//, ssum4;
  // sum of S in RS codes in block and last 4 values
  // Context model
  int N;  // number of contexts

  int hbcount;
  int *cxt;// context hashes
  int *cp; // context pointers

   char *cbuf2;
   int  *adv_pred;//, *sum;

  //for parsing Quantization tables
   int dqt_state, dqt_end , qnum;
   char *qtab;//(256); // table
   int *qmap;//(10); // block -> table number
   int  zz , acomp , q , cpos_dc ,st,zz2,tq;
   int *sumu, *sumv;
   int *ls;  // block -> distance to previous block
   int *lcp, *zpos;
   int zu, zv,a,b,comp0;
   int kk;
int min(int a, int b) {return a<b?a:b;}
int max(int a, int b) {return a<b?b:a;} 



// Detect invalid JPEG data.  The proper response is to silently
// fall back to a non-JPEG model.
void jassert(int x,int x2) {
  if (!(x))  jpeg=0;//,  printf("JPEG error at %d\n",x2); 
//  jpeg=0; \
//  return next_jpeg;
}

enum {SOF0=0xc0, SOF1, SOF2, SOF3, DHT, RST0=0xd0, SOI=0xd8, EOI, SOS, DQT,
  DNL, DRI, APP0=0xe0, COM=0xfe, FF};  // Second byte of 2 byte codes
enum {BC=9};
int find(U32 i) {
  int index,j,limit;
  int mask,bi,br;
  int chk;
  int p1,p2;
  limit=4;
  chk=(i>>24^i>>12^i)&255;
  mask=i&(tsize-1);//mask;
  bi=mask, br=1024;  // best replacement so far
  for (  j=0; j<limit; ++j) {
    index=(mask^j)*BC;//*BC;
    p1=t[index];
    p2=t[index+1];
    if (p1==chk) return index;  // match
    else if (p2==0) {t[index]=chk; return  index;}  // empty
    else if (p2<br) br=p2, bi=mask^j;  // best replacement so far
  }
  index=(bi*BC);  // replacement element
  for (j=0;j<BC;j++) t[index+j]=0;//memset(p, 0, B);

  t[index]=chk;
  return index;
}

int jpegModel(int bpos,int pos,int y) {
  int i, j;
  int len,ac, sel;//,height;
  int p,end,count,tc,val;
  int code, th, hufi, ns;
  int nf,hmax, hv,x,r;
  int s,comp,hc,coef;//, mpos;
  int pr, tttt;


  // Be sure to quit on a byte boundary
  if (!bpos) next_jpeg=jpeg>1;
  if (bpos && !jpeg) return next_jpeg;
  if (!bpos && app>0) --app;
  if (app>0) return next_jpeg;
  if (!bpos) {

  // Detect JPEG (SOI, APPx)
  if (!jpeg && buf(4)==FF && buf(3)==SOI && buf(2)==FF && buf(1)>>4==0xe) {
    jpeg=1;
    app=sos=sof=htsize=data=mcusize=0;
    huffcode=huffbits=huffsize=mcupos=cpos=0, rs=-1;
    for (i=0;i<128;i++) hufmin[i]=0;
    for (i=0;i<128;i++) hufmax[i]=0;
    for (i=0;i<128;i++) hufval[i]=0;
    for (i=0;i<4;i++) pred[i]=0;
  }

  // Detect end of JPEG when data contains a marker other than RSTx
  // or byte stuff (00).
  if (jpeg && data && buf(2)==FF && buf(1) && (buf(1)&0xf8)!=RST0) {
    jassert(buf(1)==EOI,1);
    jpeg=0;
  }
  if (!jpeg) return next_jpeg;

  // Detect APPx or COM field
  if (!data && !app && buf(4)==FF && (buf(3)>>4==0xe || buf(3)==COM))
    app=buf(2)*256+buf(1)+2;

  // Save pointers to sof, ht, sos, data,
  if (buf(5)==FF && buf(4)==SOS) {
     len=buf(3)*256+buf(2);
    if (len==6+2*buf(1) && buf(1) && buf(1)<=4)  // buf(1) is Ns
    {sos=pos-5, data=sos+len+2, jpeg=2;}
  }
  if (buf(4)==FF && buf(3)==DHT && htsize<8) ht[htsize++]=pos-4;
  if (buf(4)==FF && buf(3)==SOF0) sof=pos-4;
  
  // Parse Quantizazion tables
  if (buf(4)==FF && buf(3)==DQT) {
    dqt_end = pos + buf(2)*256 + buf(1) - 1;
    dqt_state = 0;
  } else if (dqt_state >=0) {
    if (pos >= dqt_end) {
    dqt_state = -1;
    } else {
    if (dqt_state % 65 == 0) {
      qnum = buf(1);
    } else {
      jassert(buf(1) > 0,29);
      jassert(qnum>=0 && qnum<4,30);
      qtab[qnum * 64 + ((dqt_state % 65) - 1)] = buf(1) - 1;
		  //printf("%d, ",buf(1) - 1);
    }
    dqt_state++;
    }
  }
  // Restart
  if (buf(2)==FF && (buf(1)&0xf8)==RST0) {
    huffcode=huffbits=huffsize=mcupos=0, rs=-1;
    //memset(&pred[0], 0, 4*sizeof(int));
    for (i=0;i<4;i++) pred[i]=0;
  }
  }

  {
  // Build Huffman tables
  // huf[Tc][Th][m] = min, max+1 codes of length m, pointer to byte values
  if (pos==data && bpos==1) {
    jassert(htsize>0,2);
    for ( i=0; i<htsize; ++i) {
     p=ht[i]+4;  // pointer to current table after length field
     end=p+bufr(p-2)*256+bufr(p-1)-2;  // end of Huffman table
     count=0;  // sanity check
     tttt=0;
    while (p<end && end<pos && end<(p+2100) && (++count)<10 || tttt==0) {
       tc=bufr(p)>>4, th=bufr(p)&15;
      if (tc>=2 || th>=4) tttt=1;
      if (tttt==0){
      jassert(tc>=0 && tc<2 && th>=0 && th<4,3);
       hufi=(tc*64+th*16);// [tc][th][0]; 
       val=p+17;  // pointer to values
       code=0;
      for ( j=0; j<16; ++j) {
      hufmin[j+hufi]=code;
      code=code+bufr(p+j+1);
      hufmax[j+hufi]=code;
      hufval[j+hufi]=val;
      val=val+bufr(p+j+1);
      code=code<<1;
      }
      p=val;
      }
    }
    
    jassert(p==end,4);
    }
    huffcode=huffbits=huffsize=0, rs=-1;

    // Build Huffman table selection table (indexed by mcupos).
    // Get image width.
    if (!sof && sos) return next_jpeg;
     ns=bufr(sos+4);
     nf=bufr(sof+9);
     jassert(ns<=4 && nf<=4,5);
     mcusize=0;  // blocks per MCU
     hmax=0;  // MCU horizontal dimension
    for ( i=0; i<ns; ++i) {
    for ( j=0; j<nf; ++j) {
      if (bufr(sos+2*i+5)==bufr(sof+3*j+10)) { // Cs == C ?
       hv=bufr(sof+3*j+11);  // packed dimensions H x V
      if (hv>>4>hmax) hmax=hv>>4;
      hv=(hv&15)*(hv>>4);  // number of blocks in component C
      jassert(hv>=1 && hv+mcusize<=10,6);
      while (hv) {
        jassert(mcusize<10,7);
        hufsel1[mcusize]=bufr(sos+2*i+6)>>4&15;
        hufsel2[mcusize]=bufr(sos+2*i+6)&15;
        jassert (hufsel1[mcusize]<4 && hufsel2[mcusize]<4,8);
        color[mcusize]=i;
         tq=bufr(sof+3*j+12);  // quantization table index (0..3)
        jassert(tq>=0 && tq<4,28);
        qmap[mcusize]=tq; // Quantizazion table mapping
        --hv;
        ++mcusize;
      }
      }
    }
    }
    jassert(mcusize<10,99);
    jassert(hmax>=1 && hmax<=10,9);
    for ( j=0; j<mcusize; ++j) {
    ls[j]=0;
    for ( i=1; i<mcusize; ++i) if (color[(j+i)%mcusize]==color[j]) ls[j]=i;
    ls[j]=mcusize-ls[j]<<6;
    }
    for ( j=0; j<64; ++j) zpos[(zzu[j]+8*zzv[j])&0x3F]=j;
    width=bufr(sof+7)*256+bufr(sof+8);  // in pixels
    //height=bufr(sof+5)*256+bufr(sof+6);
    //printf("JPEG %dx%d ", width, height);
    width=(width-1)/(hmax*8)+1;  // in MCU
    jassert(width>0,10);
    mcusize=mcusize*64;  // coefficients per MCU
    row=column=0;
  }
  }

  // Decode Huffman
  {
  if (mcusize && buf(1+(!bpos))!=FF) {  // skip stuffed byte
    jassert(huffbits<=32,11);
    huffcode=(huffcode<<1)|y;
    ++huffbits;
    if (rs<0) {
    jassert(huffbits>=1 && huffbits<=16,12);
      ac=(mcupos&63)>0;
     jassert(mcupos>=0 && (mcupos>>6)<10,13);
    jassert(ac==0 || ac==1,14);
    if (ac==0)      sel=hufsel1[mcupos>>6];
    else if (ac==1)     sel=hufsel2[mcupos>>6];
    else printf("error ac");
    jassert(sel>=0 && sel<4,15);
       i=huffbits-1;
    jassert(i>=0 && i<16,16);
    hufi=ac*64+sel*16;// [ac][sel];
    //jassert(h[i].min<=h[i].max && h[i].val<pos && huffbits>0);
    if (huffcode<hufmax[i+hufi]) {
      jassert(huffcode>=hufmin[i+hufi],17);
      rs=bufr(hufval[i+hufi]+huffcode-hufmin[i+hufi]);
      huffsize=huffbits;
    }
    }
    if (rs>=0) {
    if (huffsize+(rs&15)==huffbits) { // done decoding
      rs1=rs;
      x=0;  // decoded extra bits
      if (mcupos&63) {  // AC
      if (rs==0) { // EOB
        mcupos=mcupos+63&-64;
        jassert(mcupos>=0 && mcupos<=mcusize && mcupos<=640,18);
        while (cpos&63) {cbuf2[cpos&0x1FFFF]=0;
          cbuf[(cpos++)&0x1FFFF]=0;}
      }
      else {  // rs = r zeros + s extra bits for the next nonzero value
          // If first extra bit is 0 then value is negative.
        jassert((rs&15)<=10,19);
        r=rs>>4;
        s=rs&15;
        jassert(mcupos>>6==mcupos+r>>6,20);
        mcupos=mcupos+r+1;
        x=huffcode&(1<<s)-1;
        if (s && !(x>>s-1)) x=x-(1<<s)-1;
        for ( i=r; i>=1; --i) {
          cbuf2[cpos&0x1FFFF]=0;
          cbuf[(cpos++)&0x1FFFF]=i<<4|s;}
          cbuf2[cpos&0x1FFFF]=x;
        cbuf[(cpos++)&0x1FFFF]=s<<4|huffcode<<2>>s&3|12;
        ssum=ssum+s;
      }
      }
      else {  // DC: rs = 0S, s<12
      jassert(rs<12,21);
      ++mcupos;
      x=huffcode&(1<<rs)-1;
      if (rs && !(x>>rs-1)) x=x-(1<<rs)-1;
      jassert(mcupos>=0 && mcupos>>6<10,22);
        comp=color[mcupos>>6];
      jassert(comp>=0 && comp<4,23);
      pred[comp]=pred[comp]+x;
      dc=pred[comp];
      jassert((cpos&63)==0,24);
      cbuf2[cpos&0x1FFFF]=dc;
      cbuf[(cpos++)&0x1FFFF]=dc+1023>>3;
      ssum3=ssum2;
      ssum2=ssum1;
      ssum1=ssum;
      ssum=rs;
      }
      jassert(mcupos>=0 && mcupos<=mcusize,25);
      if (mcupos>=mcusize) {
      mcupos=0;
      if (++column==width) column=0, ++row;
      }
      huffcode=huffsize=huffbits=0, rs=-1;
      
      // UPDATE_ADV_PRED !!!!
      {
      acomp=mcupos>>6, q=64*qmap[acomp];
        zz=mcupos&63, cpos_dc=cpos-zz;
      if (zz==0) {
        for ( i=0; i<8; ++i) sumu[i]=sumv[i]=0;
        for ( i=0; i<64; ++i) {
        sumu[zzu[i]]=sumu[zzu[i]]+(zzv[i]?256:181)*(zzv[i]&1?-1:+1)*(qtab[q+i]+1)*cbuf2[(cpos_dc+i-mcusize*width)&0x1FFFF];
        sumv[zzv[i]]=sumv[zzv[i]]+(zzu[i]?256:181)*(zzu[i]&1?-1:+1)*(qtab[q+i]+1)*cbuf2[(cpos_dc+i-ls[acomp])&0x1FFFF];;
        }
      }
      else {
        sumu[zzu[zz-1]]=sumu[zzu[zz-1]]-(zzv[zz-1]?256:181)*(qtab[q+zz-1]+1)*cbuf2[(cpos-1)&0x1FFFF];
        sumv[zzv[zz-1]]=sumv[zzv[zz-1]]-(zzu[zz-1]?256:181)*(qtab[q+zz-1]+1)*cbuf2[(cpos-1)&0x1FFFF];
      }
      j=cbuf2[(cpos_dc-ls[acomp])&0x1FFFF];
      for ( i=0; i<3; ++i)
        for ( st=0; st<8; ++st) {
         zz2 = min(zz+st, 63);
         p=(sumu[zzu[zz2]]*i+sumv[zzv[zz2]]*(2-i))/2;
        p=p/((qtab[q+zz2]+1)*181);
        if (zz2==0) p=p-j, p=(p<0?-1:+1)*ilog(14*abs(p)+1)/10;
        else p=(p<0?-1:+1)*ilog(10*abs(p)+1)/10;
        if (st==0) {
          adv_pred[i]=p;
          adv_pred[i+4]=p/4;
        }
        else if (abs(p)>abs(adv_pred[i])+1) {
          adv_pred[i]=adv_pred[i]+st*2+(p>0)<<6;
          st=8;//break;
        }
        }
      x=2*sumu[zzu[zz]]+2*sumv[zzv[zz]];
      for ( i=0; i<8; ++i) {
        if (zzu[zz]<i) x=x-sumu[i];
        if (zzv[zz]<i) x=x-sumv[i];
      }
      x=x/((qtab[q+zz]+1)*181);
      adv_pred[3]=(x<0?-1:+1)*ilog(10*abs(x)+1)/10;

      for ( i=0; i<4; ++i) {
         a=(i&1?zzv[zz]:zzu[zz]), b=(i&2?2:1);
        if (a<b) x=255;
        else {
         zz2=zpos[zzu[zz]+8*zzv[zz]-(i&1?8:1)*b];
        x=(qtab[q+zz2]+1)*cbuf2[(cpos_dc+zz2)&0x1FFFF]/(qtab[q+zz]+1);
        x=(x<0?-1:+1)*ilog(8*abs(x)+1)/8;
        }
        lcp[i]=x;
      }

      if (column==0) adv_pred[1]=adv_pred[2], adv_pred[0]=1;
      if (row==0) adv_pred[1]=adv_pred[0], adv_pred[2]=1;
      } // !!!!

    }
    }
  }
  }

  // Estimate next bit probability
  if (!jpeg || !data) return next_jpeg;
   if (buf(1+(!bpos))==FF) {
  mxa(1,128);
  return 1;
  }
  // Update model
  if (cp[N-1]) {
  for ( i=0; i<N; ++i)
    t[cp[i]]=smn(t[cp[i]]);
  }

  // Update context
  
  if (++hbcount>2 || huffbits==0) hbcount=0;
  hc=huffcode|1<<huffbits;
  comp=color[mcupos>>6];
  comp0=comp==0;
  coef=(mcupos&63)|(comp<<6);
  zu=zzu[mcupos&63];
  zv=zzv[mcupos&63];
  jassert(coef>=0 && coef<256,26);
  if (hbcount==0) {
  //mpos=mcupos>>4|!(mcupos&-64)<<7;
  i=0;
  cxt[0]=h4(++i, hc, coef, adv_pred[2]);
  cxt[1]=h4(++i, hc, coef, adv_pred[0]);
  cxt[2]=h4(++i, hc, coef, adv_pred[1]);
  cxt[3]=h5(++i, hc, rs1, comp0, adv_pred[2]);
  cxt[4]=h5(++i, hc, rs1, comp0, adv_pred[0]);
  cxt[5]=h5(++i, hc, rs1, comp0, adv_pred[1]);
  cxt[6]=h4(++i, hc, adv_pred[2], adv_pred[0]);
  cxt[7]=h5(++i, hc, comp0, cbuf[(cpos-width*mcusize)&0x1FFFF], adv_pred[3]);
  cxt[8]=h5(++i, hc, comp0, cbuf[(cpos-ls[mcupos>>6])&0x1FFFF], adv_pred[3]);
  cxt[9]=h5(++i, hc, lcp[0], lcp[1], adv_pred[1]);
  cxt[10]=h5(++i, hc, lcp[0], lcp[1], coef);
  cxt[11]=h5(++i, hc, zu+8*comp0, lcp[0], lcp[2]/2);
  cxt[12]=h5(++i, hc, zv+8*comp0, lcp[1], lcp[3]/2);
  cxt[13]=h4(++i, hc, mcupos>>2, min(3, mcupos&63));
  cxt[14]=h4(++i, hc, coef, column>>1);
  cxt[15]=h3(++i, hc, dc);
  cxt[16]=h4(++i, hc, ssum>>4, coef);
  cxt[17]=h4(++i, hc, rs1, coef);
  cxt[18]=h5(++i, hc, mcupos>>3, ssum3>>3, adv_pred[1]);
  cxt[19]=h5(++i, hc, lcp[0]>>2, lcp[1]>>2, adv_pred[5]);
  cxt[20]=h3(++i, hc, adv_pred[1]);
  cxt[21]=h5(++i, hc, rs1, comp0, adv_pred[5]);
  cxt[22]=h4(++i, hc, comp0, adv_pred[2]);
  cxt[23]=h4(i, hc, comp0, adv_pred[0]);
  cxt[24]=h4(i, hc, comp0, adv_pred[1]);
  cxt[25]=h4(++i, hc, coef, adv_pred[4]);
  cxt[26]=h4(++i, hc, coef, adv_pred[6]);
  cxt[27]=h5(++i, hc, lcp[0], lcp[1], adv_pred[3]);
  }

  // Predict next bit
  mxa(1,128);
  jassert(hbcount<=2,27);
  for ( i=0; i<N; ++i) {
  if (hbcount==0) cp[i]=find(cxt[i])+1;
  else if (hbcount==1) cp[i]=cp[i]+1+(huffcode&1)*3;
  else cp[i]=cp[i]+1+(huffcode&1);
    smp(i,t[cp[i]],1023);
  }
  mxc(1); // mix statemap contexts into mixer 1
  mxs(1,column==0, 2);
  mxs(1, coef,256);
  mxs(1,hc&511, 512);
  pr=mxp(1);
  pr=apm(3,pr,hc&255|(adv_pred[1]&63)<<8,7);
  pr=apm(4,pr,hc&255|coef<<8,7);
  mxa(0,stretch(pr));
  return 1;
}
// update is called in VM after every bit
int update(int y,int c0,int bpos,int c4,int pos){ 
  int pr0,pr;
  int d,c;
  int isjpeg;
  mxa(0,256);
  isjpeg=jpegModel(bpos,pos,y);  // 1 if JPEG is detected, else 0

  if (isjpeg) {
    mxs(0, 1,8);
    mxs(0, c0,256);
    mxs(0, buf(1),256);
    return mxp(0);
  }
  if (bpos== 0){
    c1= buf(1), c2= buf(2), c3= buf(3);
    w4= w4*4+mpw[c1>>4];
  }

  //mix components into mixer(0) 
  //must be called before gcr - get component result
  mxc(0); 
  // set mixer(0) contexts 
  mxs(0,c1+8, 264); 
  mxs(0, c0,256);
  mxs(0,c2, 256);  
  mxs(0, gcr(0,0,MC),256); //get match result and set as mixer(0) context
  d= c0<<(8- bpos);
  mxs(0, bpos*256+(((( 1<< bpos)&255)>> bpos)|(d&255)),2048);
  if (bpos) {
    c=d; 
    if ( bpos==1)c =c+(c3>>1);
     c=(min( bpos,5))*256+(c1>>5)+8*(c2>>5)+(c&192);
   }
  else c=(c3>>7)+( c4>>31)*2+4*(c2>>6)+(c1&240); 
  
  mxs(0,c, 1536);
  mxs(0,prm, 2048);
  pr0=mxp(0);
  pr =apm(0,pr0,c0,7);
  prm=pr>>1;
  return (apm(2,pr, c0+256*c1,7)+apm(1,pr0, h2(c0,w4&0xfffff),7)+1)>>1;
}
void block(int a,int b) { 
  int i;
  jpeg=app=sos=sof=htsize=data=mcusize=huffcode=huffbits=huffsize=mcupos=cpos=0;
  rs=-1;
  for (i=0;i<128;i++) hufmin[i]=0;
  for (i=0;i<128;i++) hufmax[i]=0;
  for (i=0;i<128;i++) hufval[i]=0;
  for (i=0;i<4;i++) pred[i]=0;
}
// main is called only once after VM init.
int main() { 
  int i;
  printf("JPEG model v4\n");
  N=28;
  tsize=0x1000000;// MEM at -8
  if (!(t = malloc((tsize*BC),sizeof(char)))) exit(-1);
  if (!(cbuf = malloc(0x20000,sizeof(char)))) exit(-1);
  if (!(cxt = malloc(N,sizeof(int)))) exit(-1);
  if (!(cp = malloc(N,sizeof(int)))) exit(-1);
  if (!(color = malloc(10,sizeof(int)))) exit(-1);
  if (!(pred = malloc(4,sizeof(int)))) exit(-1);
  if (!(ht = malloc(8,sizeof(int)))) exit(-1);
  if (!(hufsel1 = malloc(10,sizeof(int)))) exit(-1);
  if (!(hufsel2 = malloc(10,sizeof(int)))) exit(-1);
  if (!(hufmin = malloc(128,sizeof(int)))) exit(-1);
  if (!(hufmax = malloc(128,sizeof(int)))) exit(-1);
  if (!(hufval = malloc(128,sizeof(int)))) exit(-1);
  if (!(cbuf2 = malloc(0x20000,sizeof(int)))) exit(-1);
  if (!(adv_pred = malloc(7,sizeof(int)))) exit(-1);
  if (!(qtab = malloc(256,sizeof(char)))) exit(-1);
  if (!(qmap = malloc(10,sizeof(int)))) exit(-1);
  if (!(sumu = malloc(8,sizeof(int)))) exit(-1);
  if (!(sumv = malloc(8,sizeof(int)))) exit(-1);
  if (!(ls = malloc(10,sizeof(int)))) exit(-1);
  if (!(lcp = malloc(4,sizeof(int)))) exit(-1);
  if (!(zpos = malloc(64,sizeof(int)))) exit(-1);

  //  SMC,APM1,APM2,RCM,SCM,MCM, CM,MX, MC (1,2,3,4,5,6,7,8,9)
  vms(  N,   5,   0,  0,  0,  0, 0, 2,  1) ; 
  for (i=0;i<N;i++) vmi(SMC,i,256,0,1);
  vmi(MC,0,-2,4096,0);//match(0), mem/2,len 4096,mixer(0)
  vmi(APM1,0,256,0,-1);  //APM1(0) contexts, 0, no mixer
  vmi(APM1,1,0x10000,0,-1);
  vmi(APM1,2,0x10000,0,-1);
  vmi(APM1,3,0x1000,0,-1);
  vmi(APM1,4,0x10000,0,-1);
  vmi(MX,0,682+200+18,264+256+256+256+2048+1536+2048,7);  
  vmi(MX,1,N+1,770,4); 
  w4=0;
  prm=1024;
  hbcount=2;
  jpeg=next_jpeg=app=sof=sos=data=htsize=huffcode=huffbits=huffsize=0;
  rs=-1;
  mcupos=mcusize=dc=width=row=column=cpos=ssum=ssum1=ssum2=ssum3=0;
  dqt_state = -1, dqt_end=qnum=c1=c2=c3=0;
}
