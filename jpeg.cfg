//                           jpegModel
// Model JPEG. Return 1 if a JPEG file is detected or else 0.
// Only the baseline and 8 bit extended Huffman coded DCT modes are
// supported.  The model partially decodes the JPEG image to provide
// context for the Huffman coded symbols.
//
enum {SMC=1,APM1,APM2,RCM,SCM,MCM,CM,MX,MC};
char *t;
  // context hash -> bit history
  // As a cache optimization, the context does not include the last 1-2
  // bits of huffcode if the length (huffbits) is not a multiple of 3.
  // The 7 mapped values are for context+{"", 0, 00, 01, 1, 10, 11}.
int tsize;
int c1,c2,c3;
int w4,prm,Misses,pr1;
int mpw[16]= {4,4,3,2,2,2,1,1,1,1,1,1,0,0,0,0};
int zzu[64]={  // zigzag coef -> u,v
  0,1,0,0,1,2,3,2,1,0,0,1,2,3,4,5,4,3,2,1,0,0,1,2,3,4,5,6,7,6,5,4,
  3,2,1,0,1,2,3,4,5,6,7,7,6,5,4,3,2,3,4,5,6,7,7,6,5,4,5,6,7,7,6,7};
int zzv[64]={
  0,0,1,2,1,0,0,1,2,3,4,3,2,1,0,0,1,2,3,4,5,6,5,4,3,2,1,0,0,1,2,3,
  4,5,6,7,7,6,5,4,3,2,1,2,3,4,5,6,7,7,6,5,4,3,4,5,6,7,7,6,5,6,7,7};

   // State of parser
   int jpeg;  // 1 if JPEG is detected
   int next_jpeg;  // updated with jpeg on next byte boundary
   int app;  // Bytes remaining to skip in APPx or COM field
   int sof, sos, data;  // pointers to buf
   int *ht;  // pointers to Huffman table headers
   int htsize;  // number of pointers in ht

   // Huffman decode state
   int huffcode;  // Current Huffman code including extra bits
   int huffbits;  // Number of valid bits in huffcode
   int huffsize;  // Number of bits without extra bits
   int rs;  // Decoded huffcode without extra bits.  It represents
  // 2 packed 4-bit numbers, r=run of zeros, s=number of extra bits for
  // first nonzero code.  huffcode is complete when rs >= 0.
  // rs is -1 prior to decoding incomplete huffcode.
   int mcupos;  // position in MCU (0-639).  The low 6 bits mark
  // the coefficient in zigzag scan order (0=DC, 1-63=AC).  The high
  // bits mark the block within the MCU, used to select Huffman tables.

   // Decoding tables
   // Tc*64+Th*16+m -> min, max, val
   int *hufmin;
   int *hufmax;
   int *hufval;
   int mcusize;  // number of coefficients in an MCU
  // int linesize; // width of image in MCU
   int *hufsel1; // DC/AC, mcupos/64 -> huf decode table
   int *hufsel2;
   // Image state
   int* color;  // block -> component (0-3)
   int* pred;  // component -> last DC value
   int dc;  // DC value of the current block
   int width;  // Image width in MCU
   int row, column;  // in MCU (column 0 to width-1)
   char* cbuf; // Rotating buffer of coefficients, coded as:
  // DC: level shifted absolute value, low 4 bits discarded, i.e.
  //   [-1023...1024] -> [0...255].
  // AC: as an RS code: a run of R (0-15) zeros followed by an S (0-15)
  //   bit number, or 00 for end of block (in zigzag order).
  //   However if R=0, then the format is ssss11xx where ssss is S,
  //   xx is the first 2 extra bits, and the last 2 bits are 1 (since
  //   this never occurs in a valid RS code).
   int cpos;  // position in cbuf
   //int huff1, huff2, huff3, huff4;  // hashes of last codes
   int rs1;//, rs2, rs3, rs4;  // last 4 RS codes
   int ssum, ssum1, ssum2, ssum3;//, ssum4;
  // sum of S in RS codes in block and last 4 values
  // Context model
  int N;  // number of contexts

  int hbcount;
  int *cxt;// context hashes
  int *cp; // context pointers

   int *cbuf2;
   int  *adv_pred;
  //for parsing Quantization tables
   int dqt_state, dqt_end , qnum;
   char *qtab;//(256); // table
   int *qmap;//(10); // block -> table number
   int  zz , acomp , q , cpos_dc ,st,zz2,tq;
   int *sumu, *sumv;
   int *ls;  // block -> distance to previous block
   int *lcp, *zpos;
   int zu, zv,a,b,comp0;
   int kk,prev_coef_rs,prev_coef,prev_coef2,rstpos,rstlen;
   int prev1,prev2,cnt1,cnt2;
int min(int a, int b) {return a<b?a:b;}
int max(int a, int b) {return a<b?b:a;} 
int abs(int x){
    if (x>=0) return x;
    else return (0-x);
}


// Detect invalid JPEG data.  The proper response is to silently
// fall back to a non-JPEG model.
void jassert(int x,int x2) {
  if (!(x))  jpeg=0 ,  printf("JPEG error at %d\n",x2); 
//  jpeg=0; \
//  return next_jpeg;
}

enum {SOF0=0xc0, SOF1, SOF2, SOF3, DHT, RST0=0xd0, SOI=0xd8, EOI, SOS, DQT,
  DNL, DRI, APP0=0xe0, COM=0xfe, FF};  // Second byte of 2 byte codes
enum {BC=9};
int find(U32 i) {
  int index,j,limit;
  int mask,bi,br;
  int chk;
  int p1,p2;
  limit=4;
  chk=(i>>24^i>>12^i)&255;
  mask=i&(tsize-1);//mask;
  bi=mask, br=1024;  // best replacement so far
  for (  j=0; j<limit; ++j) {
    index=(mask^j)*BC;//*BC;
    p1=t[index];
    p2=t[index+1];
    if (p1==chk) return index;  // match
    else if (p2==0) {t[index]=chk; return  index;}  // empty
    else if (p2<br) br=p2, bi=mask^j;  // best replacement so far
  }
  index=(bi*BC);  // replacement element
  for (j=0;j<BC;j++) t[index+j]=0;//memset(p, 0, B);

  t[index]=chk;
  return index;
}

int jpegModel(int bpos,int pos,int y) {
  int i, j;
  int len,ac, sel;//,height;
  int p,end,count,tc,val;
  int code, th, hufi, ns;
  int nf,hmax, hv,x,r;
  int s,comp,hc,coef;
  int pr, tttt,cpos_dc_ls_acomp, cpos_dc_mcusize_width,huc;
  

  // Be sure to quit on a byte boundary
  if (!bpos) next_jpeg=jpeg>1;
  if (bpos && !jpeg) return next_jpeg;
  if (!bpos && app>0) --app;
  if (app>0) return next_jpeg;
  if (!bpos) {

  // Detect JPEG (SOI, APPx)
  if (!jpeg && buf(4)==FF && buf(3)==SOI && buf(2)==FF && buf(1)>>4==0xe) {
    jpeg=1;
    app=sos=sof=htsize=data=mcusize=0;
    huffcode=huffbits=huffsize=mcupos=cpos=0, rs=-1;
    for (i=0;i<128;i++) hufmin[i]=0;
    for (i=0;i<128;i++) hufmax[i]=0;
    for (i=0;i<128;i++) hufval[i]=0;
    for (i=0;i<4;i++) pred[i]=0;
	prev1=0,prev2=0,cnt1=0,cnt2=0;
	prev_coef=0,prev_coef2=0;
	rstpos=rstlen=0;
  }

  // Detect end of JPEG when data contains a marker other than RSTx
  // or byte stuff (00).
  if (jpeg && data && buf(2)==FF && buf(1) && (buf(1)&0xf8)!=RST0) {
    jassert(buf(1)==EOI,1);
    jpeg=0;
  }
  if (!jpeg) return next_jpeg;

  // Detect APPx or COM field
  if (!data && !app && buf(4)==FF && (buf(3)>>4==0xe || buf(3)==COM))
    app=buf(2)*256+buf(1)+2;

  // Save pointers to sof, ht, sos, data,
  if (buf(5)==FF && buf(4)==SOS) {
     len=buf(3)*256+buf(2);
    if (len==6+2*buf(1) && buf(1) && buf(1)<=4)  // buf(1) is Ns
    {sos=pos-5, data=sos+len+2, jpeg=2;}
  }
  if (buf(4)==FF && buf(3)==DHT && htsize<8) ht[htsize++]=pos-4;
  if (buf(4)==FF && buf(3)==SOF0) sof=pos-4;
  
  // Parse Quantizazion tables
  if (buf(4)==FF && buf(3)==DQT) {
    dqt_end = pos + buf(2)*256 + buf(1) - 1;
    dqt_state = 0;
  } else if (dqt_state >=0) {
    if (pos >= dqt_end) {
    dqt_state = -1;
    } else {
    if (dqt_state % 65 == 0) {
      qnum = buf(1);
    } else {
      jassert(buf(1) > 0,29);
      jassert(qnum>=0 && qnum<4,30);
      qtab[qnum * 64 + ((dqt_state % 65) - 1)] = buf(1) - 1;
		  //printf("%d %d, ",qnum * 64 + ((dqt_state % 65) - 1),buf(1) - 1);
    }
    dqt_state++;
    }
  }
  // Restart
  if (buf(2)==FF && (buf(1)&0xf8)==RST0) {
    huffcode=huffbits=huffsize=mcupos=0, rs=-1;
    //memset(&pred[0], 0, 4*sizeof(int));
    for (i=0;i<4;i++) pred[i]=0;
	rstlen=column+row*width-rstpos;
      rstpos=column+row*width;
  }
  }

  {
  // Build Huffman tables
  // huf[Tc][Th][m] = min, max+1 codes of length m, pointer to byte values
  if (pos==data && bpos==1) {
    jassert(htsize>0,2);
    for ( i=0; i<htsize; ++i) {
     p=ht[i]+4;  // pointer to current table after length field
     end=p+bufr(p-2)*256+bufr(p-1)-2;  // end of Huffman table
     count=0;  // sanity check
     tttt=0;
    while (p<end && end<pos && end<(p+2100) && (++count)<10 || tttt==0) {
       tc=bufr(p)>>4, th=bufr(p)&15;
      if (tc>=2 || th>=4) tttt=1;
      if (tttt==0){
      jassert(tc>=0 && tc<2 && th>=0 && th<4,3);
       hufi=(tc*64+th*16);// [tc][th][0]; 
       val=p+17;  // pointer to values
       code=0;
      for ( j=0; j<16; ++j) {
		 jassert( j+hufi<128,1288);
      hufmin[j+hufi]=code;
      code=code+bufr(p+j+1);
      hufmax[j+hufi]=code;
      hufval[j+hufi]=val;
      val=val+bufr(p+j+1);
      code=code<<1;
      }
      p=val;
      }
    }
    
    jassert(p==end,4);
    }
    huffcode=huffbits=huffsize=0, rs=-1;

    // Build Huffman table selection table (indexed by mcupos).
    // Get image width.
    if (!sof && sos) return next_jpeg;
     ns=bufr(sos+4);
     nf=bufr(sof+9);
     jassert(ns<=4 && nf<=4,5);
     mcusize=0;  // blocks per MCU
     hmax=0;  // MCU horizontal dimension
    for ( i=0; i<ns; ++i) {
    for ( j=0; j<nf; ++j) {
      if (bufr(sos+2*i+5)==bufr(sof+3*j+10)) { // Cs == C ?
       hv=bufr(sof+3*j+11);  // packed dimensions H x V
      if (hv>>4>hmax) hmax=hv>>4;
      hv=(hv&15)*(hv>>4);  // number of blocks in component C
      jassert(hv>=1 && hv+mcusize<=10,6);
      while (hv) {
        jassert(mcusize<10,7);
        hufsel1[mcusize]=bufr(sos+2*i+6)>>4&15;
        hufsel2[mcusize]=bufr(sos+2*i+6)&15;
        jassert (hufsel1[mcusize]<4 && hufsel2[mcusize]<4,8);
        color[mcusize]=i;
         tq=bufr(sof+3*j+12);  // quantization table index (0..3)
        jassert(tq>=0 && tq<4,28);
        qmap[mcusize]=tq; // Quantizazion table mapping
        --hv;
        ++mcusize;
      }
      }
    }
    }
    jassert(mcusize<10,99);
    jassert(hmax>=1 && hmax<=10,9);
    for ( j=0; j<mcusize; ++j) {
    ls[j]=0;
    for ( i=1; i<mcusize; ++i) if (color[(j+i)%mcusize]==color[j]) ls[j]=i;
    ls[j]=mcusize-ls[j]<<6;
    }
    for ( j=0; j<64; ++j) zpos[(zzu[j]+8*zzv[j])&0x3F]=j;
    width=bufr(sof+7)*256+bufr(sof+8);  // in pixels
    //height=bufr(sof+5)*256+bufr(sof+6);
    //printf("JPEG %dx%d ", width, height);
    width=(width-1)/(hmax*8)+1;  // in MCU
    jassert(width>0,10);
    mcusize=mcusize*64;  // coefficients per MCU
    row=column=0;
  }
  }

  // Decode Huffman
  {
  if (mcusize && buf(1+(!bpos))!=FF) {  // skip stuffed byte
    jassert(huffbits<=32,11);
    huffcode=(huffcode<<1)|y;
    ++huffbits;
    if (rs<0) {
    jassert(huffbits>=1 && huffbits<=16,12);
      ac=(mcupos&63)>0;
     jassert(mcupos>=0 && (mcupos>>6)<10,13);
    //jassert(ac==0 || ac==1,14);
    if (ac==0)      sel=hufsel1[mcupos>>6];
    else if (ac==1)     sel=hufsel2[mcupos>>6];
    else printf("error ac");
    //jassert(sel>=0 && sel<4,15);
       i=huffbits-1;
    //jassert(i>=0 && i<16,16);
    hufi=ac*64+sel*16;// [ac][sel];
    //jassert(hufmin[i+hufi]<=hufmax[i+hufi] && hufval[i+hufi]<pos && huffbits>0,1777);
    if (huffcode<hufmax[i+hufi]) {
      //jassert(huffcode>=hufmin[i+hufi],17);
      rs=bufr(hufval[i+hufi]+huffcode-hufmin[i+hufi]);
      huffsize=huffbits;
    }
    }
    if (rs>=0) {
    if (huffsize+(rs&15)==huffbits) { // done decoding
      rs1=rs;
      x=0;  // decoded extra bits
      if (mcupos&63) {  // AC
      if (rs==0) { // EOB
        mcupos=mcupos+63&-64;
        //jassert(mcupos>=0 && mcupos<=mcusize && mcupos<=640,18);
        while (cpos&63) {cbuf2[cpos&0x1FFFF]=0;
          cbuf[(cpos++)&0x1FFFF]=0;}
      }
      else {  // rs = r zeros + s extra bits for the next nonzero value
          // If first extra bit is 0 then value is negative.
        jassert((rs&15)<=10,19);
        r=rs>>4;
        s=rs&15;
        jassert(mcupos>>6==mcupos+r>>6,20);
        mcupos=mcupos+(r+1);
        x=huffcode&((1<<s)-1);
        if (s && !(x>>s-1)) x=x-((1<<s)-1);
        for ( i=r; i>=1; --i) {
          cbuf2[cpos&0x1FFFF]=0;
          cbuf[(cpos++)&0x1FFFF]=i<<4|s;
		}
          cbuf2[cpos&0x1FFFF]=x;
        cbuf[(cpos++)&0x1FFFF]=(s<<4)|(((huffcode<<2)>>s)&3)|12;;
        ssum=ssum+s;
      }
      }
      else {  // DC: rs = 0S, s<12
      jassert(rs<12,21);
      ++mcupos;
      x=huffcode&((1<<rs)-1);
      if (rs && !(x>>rs-1)) x=x-((1<<rs)-1);
      jassert(mcupos>=0 && mcupos>>6<10,22);
        comp=color[mcupos>>6];
      jassert(comp>=0 && comp<4,23);
      pred[comp]=pred[comp]+x;
      dc=pred[comp];
      jassert((cpos&63)==0,24);
      cbuf2[cpos&0x1FFFF]=dc;
      cbuf[(cpos++)&0x1FFFF]=(dc+1023)>>3;
      if ((mcupos>>6)==0) {
              ssum1=0;
              ssum2=ssum3;
            } else {
              if (color[(mcupos>>6)-1]==color[0]) {ssum3=ssum,ssum1=ssum1+ssum;}
              ssum2=ssum1;
            }
      ssum=rs;
      }
      jassert(mcupos>=0 && mcupos<=mcusize,25);
      if (mcupos>=mcusize) {
      mcupos=0;
      if (++column==width) column=0, ++row;
      }
      huffcode=huffsize=huffbits=0, rs=-1;
      
      // UPDATE_ADV_PRED !!!!
      {
      acomp=mcupos>>6, q=64*qmap[acomp];
        zz=mcupos&63, cpos_dc=cpos-zz;
      if (zz==0) {
        for ( i=0; i<8; ++i) sumu[i]=sumv[i]=0;
		cpos_dc_ls_acomp = cpos_dc-ls[acomp];
		cpos_dc_mcusize_width = cpos_dc-mcusize*width;
        for ( i=0; i<64; ++i) {
        sumu[zzu[i]]=sumu[zzu[i]]+(zzv[i]&1?-1:1)*(zzv[i]?16*(16+zzv[i]):181)*(qtab[q+i]+1)*cbuf2[(cpos_dc_mcusize_width+i)&0x1FFFF];
        sumv[zzv[i]]=sumv[zzv[i]]+(zzu[i]&1?-1:1)*(zzu[i]?16*(16+zzu[i]):181)*(qtab[q+i]+1)*cbuf2[(cpos_dc_ls_acomp+i)&0x1FFFF];
        }
      }
      else {
        sumu[zzu[zz-1]]=sumu[zzu[zz-1]]-((zzv[zz-1]?16*(16+zzv[zz-1]):181)*(qtab[q+zz-1]+1)*cbuf2[(cpos-1)&0x1FFFF]);
        sumv[zzv[zz-1]]=sumv[zzv[zz-1]]-((zzu[zz-1]?16*(16+zzu[zz-1]):181)*(qtab[q+zz-1]+1)*cbuf2[(cpos-1)&0x1FFFF]);
      }
      for ( i=0; i<3; ++i){
        for ( st=0; st<8; ++st) {
         zz2 = min(zz+st, 63);
         p=(sumu[zzu[zz2]]*i+sumv[zzv[zz2]]*(2-i))/2;
        p=p/((qtab[q+zz2]+1)*181*(16+zzv[zz2])*(16+zzu[zz2])/256);
        if (zz2==0)  p=p-cbuf2[(cpos_dc-ls[acomp])&0x1FFFF];
         p=(p<0?-1:+1)*ilog(10*abs(p)+1)/10;
        if (st==0) {
          adv_pred[i]=p;
          adv_pred[i+4]=p/4;
        }
        else if (abs(p)>abs(adv_pred[i])+1) {
          adv_pred[i]=adv_pred[i]+((st*2+(p>0))<<6);
          if (abs(p/4)>abs(adv_pred[i+4])+1) adv_pred[i+4]=adv_pred[i+4]+((st*2+(p>0))<<6);
          st=8;//break;
        }
       }
	  }
      x=2*sumu[zzu[zz]]+2*sumv[zzv[zz]];
      for ( i=0; i<8; ++i) x=x-((zzu[zz]<i)*sumu[i]+(zzv[zz]<i)*sumv[i]);
      x=x/((qtab[q+zz]+1)*181);
      if (zz==0) x=x-cbuf2[(cpos_dc-ls[acomp])&0x1FFFF];
      adv_pred[3]=(x<0?-1:+1)*ilog(10*abs(x)+1)/10;

      for ( i=0; i<4; ++i) {
         a=(i&1?zzv[zz]:zzu[zz]), b=(i&2?2:1);
        if (a<b) x=255;
        else {
         zz2=zpos[zzu[zz]+8*zzv[zz]-(i&1?8:1)*b];
        x=((qtab[q+zz2]+1)*cbuf2[(cpos_dc+zz2)&0x1FFFF])/(qtab[q+zz]+1);
        x=(x<0?-1:+1)*ilog(10*abs(x)+1)/10;
        }
        lcp[i]=x;
      }
        r=0;s=0;cnt2=0;cnt1=0;prev1=0;prev2=0;
        prev_coef_rs = cbuf[(cpos-64)&0x1FFFF];
        for ( i=0; i<acomp; i++) {
          x=0;
          x=x+cbuf2[(cpos-(acomp-i)*64)&0x1FFFF];
          if (zz==0 && ((rstpos!=column+row*width) || ls[i]==64)) x=x-cbuf2[(cpos_dc-(acomp-i)*64-ls[i])&0x1FFFF];
          if (color[i]==color[acomp]-1) { prev1=prev1+x; cnt1++; r=r+(cbuf[(cpos-(acomp-i)*64)&0x1FFFF]>>4); s=s+(cbuf[(cpos-(acomp-i)*64)&0x1FFFF]&0xF); }
          if (color[acomp]>1 && color[i]==color[0]) { prev2=prev2+x; cnt2++; }
        }
        if (cnt1>0) prev1=prev1/cnt1, r=r/cnt1, s=s/cnt1, prev_coef_rs=(r<<4)|s;
        if (cnt2>0) prev2=prev2/cnt2;
        prev_coef=(prev1<0?-1:+1)*ilog(11*abs(prev1)+1)+(cnt1<<20);
        prev_coef2=(prev2<0?-1:+1)*ilog(11*abs(prev2)+1);
      if (column==0) adv_pred[1]=adv_pred[2], adv_pred[0]=1;
      if (row==0) adv_pred[1]=adv_pred[0], adv_pred[2]=1;
      } // !!!!

    }
    }
  }
  }

  // Estimate next bit probability
  if (!jpeg || !data) return next_jpeg;
   if (buf(1+(!bpos))==FF) {
  mxa(1,128);
  return 1;
  }
  // Update model
  if (cp[N-1]) {
  for ( i=0; i<N; ++i)
    t[cp[i]]=smn(t[cp[i]]);
  }

  // Update context
  
  if (++hbcount>2 || huffbits==0) hbcount=0;
  
  comp=color[acomp];
  hc=( huffcode*4+(zz==0)*2+(comp==0))|1<<(huffbits+2);
  comp0=comp==0;
  coef=zz|(comp<<6);
  zu=zzu[zz];
  zv=zzv[zz];
  jassert(coef>=0 && coef<256,26);
  if (hbcount==0) {
  i=hc*32;
  cxt[0]=h4(++i,  coef, adv_pred[2], h2(ssum2>>6, prev_coef/72));
  cxt[1]=h4(++i,  coef, adv_pred[0], h2(ssum2>>6, prev_coef/72));
  cxt[2]=h4(++i,  coef, adv_pred[1], ssum2>>6);
  cxt[3]=h4(++i,  rs1,  adv_pred[2], prev_coef/10);
  cxt[4]=h4(++i,  rs1,  adv_pred[0], prev_coef/10);
  cxt[5]=h3(++i,  rs1,  adv_pred[1]);
  cxt[6]=h3(++i,  adv_pred[2], adv_pred[0]);
  cxt[7]=h3(++i,  cbuf[(cpos-width*mcusize)&0x1FFFF], adv_pred[3]);
  cxt[8]=h3(++i,  cbuf[(cpos-ls[acomp])&0x1FFFF], adv_pred[3]);
  cxt[9]=h4(++i,  lcp[0], lcp[1], adv_pred[1]);
  cxt[10]=h4(++i, lcp[0], lcp[1], zz);
  cxt[11]=h4(++i, zu, h2(lcp[0], lcp[2]/3), (prev_coef/40)|((prev_coef2/28)<<20));
  cxt[12]=h4(++i, zv, h2(lcp[1], lcp[3]/3), (prev_coef/40)|((prev_coef2/28)<<20));
  cxt[13]=h2(++i, mcupos>>1);
  cxt[14]=h3(++i, zz, column>>1);
  cxt[15]=h4(++i, column>>3, lcp[0]+256*(lcp[2]/4), lcp[1]+256*(lcp[3]/4));
  cxt[16]=h3(++i, ssum>>3, zz);
  cxt[17]=h3(++i, rs1,  zz);
  cxt[18]=h4(++i, mcupos>>3, ssum2>>5, adv_pred[3]);
  cxt[19]=h4(++i, lcp[0]/4, lcp[1]/4, adv_pred[5]);
  cxt[20]=h4(++i, zv,cbuf[(cpos-width*mcusize)&0x1FFFF],adv_pred[6]);
  cxt[21]=h4(++i, zu, cbuf[(cpos-ls[acomp])&0x1FFFF], adv_pred[4]);
  cxt[22]=h2(++i, adv_pred[2]);
  cxt[23]=h2(i,   adv_pred[0]);
  cxt[24]=h2(i,   adv_pred[1]);
  cxt[25]=h4(++i, zv, lcp[1], adv_pred[6]);
  cxt[26]=h4(++i, zu, lcp[0], adv_pred[4]);
  cxt[27]=h4(++i, lcp[0]/14, lcp[1]/14, adv_pred[3]/16);
  cxt[28]=h4(++i, coef, adv_pred[1]/17, h3(lcp[(zu<zv)]/24,lcp[2]/20,lcp[3]/24));
  cxt[29]=h4(++i, coef, adv_pred[3]/11, h3(lcp[(zu<zv)]/50,lcp[2*(zu*zv>1)]/50,lcp[3*(zu*zv>1)]/50));
  cxt[30]=h4(++i, coef, ssum>>2, prev_coef_rs);//cxt[30]=h4(++i, coef, prev_coef/10, prev_coef2/20);
  }

  // Predict next bit
  mxa(1,128);
  jassert(hbcount<=2,27);
  if (hbcount==0)      for ( i=0; i<N; ++i) {cp[i]=find(cxt[i])+1; pr=smp(i,t[cp[i]],1023);mxa(0,(pr-2048)>>3);mxa(1,stretch(pr));}
  else if (hbcount==1) {huc=1+(huffcode&1)*3; for ( i=0; i<N; ++i) {cp[i]=cp[i]+huc; pr=smp(i,t[cp[i]],1023);mxa(0,(pr-2048)>>3);mxa(1,stretch(pr));}}
  else {    huc=1+(huffcode&1); for ( i=0; i<N; ++i) {cp[i]=cp[i]+huc; pr=smp(i,t[cp[i]],1023);mxa(0,(pr-2048)>>3);mxa(1,stretch(pr));}}
 
  mxc(1); // mix statemap contexts into mixer 1
  mxs(1,column==0, 2);
  mxs(1, coef,256);
  mxs(1,hc&511, 512);
  pr=mxp(1);
  mxa(0,stretch(pr));
  pr=apm(3,pr,hc&511|(adv_pred[1]==0?0:(abs(adv_pred[1])-4)&63)<<9,7);
  pr=apm(4,pr,hc&255|coef<<8,7);
  mxa(0,stretch(pr));
  return 2+(hc&255);
}
// update is called in VM after every bit
int update(int y,int c0,int bpos,int c4,int pos){ 
  int pr0;
  int d,c;
  int isjpeg;
  mxa(0,256);
  mxa(0,(stretch(smp(N,c0,1023))+1)>>1);
  mxa(0,(stretch(smp(N+1,c0|(buf(1)<<8),1023))+1)>>1);
  isjpeg=jpegModel(bpos,pos,y);  // 1 if JPEG is detected, else 0

  if (isjpeg) {
    mxs(0, 1,8);
    mxs(0, isjpeg-1,257);
    mxs(0, buf(1),256);
    return mxp(0);
  }
  if (bpos== 0){
    c1= buf(1), c2= buf(2), c3= buf(3);
    w4= w4*4+mpw[c1>>4];
  }

  //mix components into mixer(0) 
  //must be called before gcr - get component result
  mxc(0); 
  // set mixer(0) contexts 
  mxs(0,c1+8, 264); 
  mxs(0,c0,256);
  mxs(0,c2, 256);  
  d= c0<<(8- bpos);
  mxs(0, bpos*256+(((( 1<< bpos)&255)>> bpos)|(d&255)),2048);
  if (bpos) {
    c=d; 
    if ( bpos==1)c =c+(c3>>1);
     c=(min( bpos,5))*256+(c1>>5)+8*(c2>>5)+(c&192);
   }
  else c=(c3>>7)+( c4>>31)*2+4*(c2>>6)+(c1&240); 
  
  mxs(0,c, 1536);
  mxs(0,prm, 2048);
  pr0=mxp(0);
  Misses=(Misses<<1)|((pr1>>11)!=y);
  pr1 =apm(0,pr0,(c0<<4)|(Misses&0xF),7);
  prm=pr1>>1;
  return (apm(2,pr1, c0+256*c1,7)+apm(1,pr0, h2(c0,w4&0xfffff),7)+1)>>1;
}
void block(int a,int b) { 
  int i;
  jpeg=app=sos=sof=htsize=data=mcusize=huffcode=huffbits=huffsize=mcupos=cpos=0;
  rs=-1;
  for (i=0;i<128;i++) hufmin[i]=hufmax[i]=hufval[i]=0;
  for (i=0;i<4;i++) pred[i]=0;
}
// main is called only once after VM init.
int main() { 
  int i,sint;
  printf("JPEG model v7\n");
  N=31;
  sint=sizeof(int);
  tsize=0x1000000;// MEM at -8
  if (!(t = malloc((tsize*BC),sizeof(char)))) exit(-1);
  if (!(cbuf = malloc(0x20000,sizeof(char)))) exit(-1);
  if (!(cxt = malloc(N,sint))) exit(-1);
  if (!(cp = malloc(N,sint))) exit(-1);
  if (!(color = malloc(10,sint))) exit(-1);
  if (!(pred = malloc(4,sint))) exit(-1);
  if (!(ht = malloc(8,sint))) exit(-1);
  if (!(hufsel1 = malloc(10,sint))) exit(-1);
  if (!(hufsel2 = malloc(10,sint))) exit(-1);
  if (!(hufmin = malloc(128,sint))) exit(-1);
  if (!(hufmax = malloc(128,sint))) exit(-1);
  if (!(hufval = malloc(128,sint))) exit(-1);
  if (!(cbuf2 = malloc(0x20000,sint))) exit(-1);
  if (!(adv_pred = malloc(7,sint))) exit(-1);
 
  if (!(qtab = malloc(256,sizeof(char)))) exit(-1);
  if (!(qmap = malloc(10,sint))) exit(-1);
  if (!(sumu = malloc(8,sint))) exit(-1);
  if (!(sumv = malloc(8,sint))) exit(-1);
  if (!(ls = malloc(10,sint))) exit(-1);
  if (!(lcp = malloc(4,sint))) exit(-1);
  if (!(zpos = malloc(64,sint))) exit(-1);

  //  SMC,APM1,APM2,RCM,SCM,MCM, CM,MX, MC (1,2,3,4,5,6,7,8,9)
  vms(  N+2,   5,   0,  0,  0,  0, 0, 2,  0) ; 
  for (i=0;i<N;i++) vmi(SMC,i,256,0,1);
  vmi(SMC,N,256,0,-1);
  vmi(SMC,N+1,256*256,0,-1);
  vmi(APM1,0,0x1000,0,-1);  //APM1(0) contexts, 0, no mixer
  vmi(APM1,1,0x10000,0,-1);
  vmi(APM1,2,0x10000,0,-1);
  vmi(APM1,3,0x8000,0,-1);
  vmi(APM1,4,0x10000,0,-1);
  vmi(MX,0,4+1+N,264+256+256+256+2048+1536+2048+1,6);  
  vmi(MX,1,N+1+N,770,4); 
  w4=pr1=Misses=0;
  prm=1024;
  hbcount=2;
  jpeg=next_jpeg=app=sof=sos=data=htsize=huffcode=huffbits=huffsize=0;
  rs=-1;
  mcupos=mcusize=dc=width=row=column=cpos=ssum=ssum1=ssum2=ssum3=0;
  dqt_state = -1, dqt_end=qnum=c1=c2=c3=0;
}
