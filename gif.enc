 
int *table ;
char *output;
int *dict;
char *src;
enum {LZW_TABLE_SIZE=9221,PHI=0x9E3779B1}; //internal enum
enum {false=0,true}; //internal enum
enum {END=0xFFFFFFFE,START=0xFFFFFFFF}; //external enum
int offset;
int index;
void lzw_find(int k) {
	 int stride,true;
	 true=0;
  offset = ((k)*PHI)>>19; 
   stride = (offset>0)?LZW_TABLE_SIZE-offset:1; 
  while (true==0){ 
  index=table[offset];
    if ((index)<0){ index=0-offset-1; true=1; } 
    else if (dict[index]==(k)){ true=1; } 
    else offset=offset-stride; 
    if (offset<0 && true==0) 
      offset=offset+LZW_TABLE_SIZE; 
  } 
}

void lzw_reset() { 
int i;
for ( i=0; i<LZW_TABLE_SIZE; i++){
	table[i]=-1;
}
 }

int encode(int info,int len) {
	int codesize,hdrsize,clearpos,bsize,code,diffpos,phase, bits,shift,end;
	int i,j,blocksize,maxcode,last,buff,key,curpos,size,readbytes;
  //int codesize=in->getc(),hdrsize=6,clearpos=0,bsize=0,code,offset=0;
  hdrsize=6,clearpos=0,bsize=0,diffpos=0,curpos=0,readbytes=0;
  read(src, 1);
  codesize=src[0];
  //printf(" encode codesize %d\n",codesize);
  ///int diffpos=0,beginin= in->curpos(),beginout= out->curpos();
  //Array<U8,1> output(4096);
  src[0]=hdrsize>>8;write(src,1);//out->putc(hdrsize>>8);
  src[0]=hdrsize&255;write(src,1);//out->putc(hdrsize&255);
  src[0]=255-bsize;write(src,1);//out->putc(255-bsize);
  src[0]=(clearpos>>8)&255;write(src,1);//out->putc((clearpos>>8)&255);
  src[0]=clearpos&255;write(src,1);//out->putc(clearpos&255);
 // printf("encode clearpos %d\n",clearpos);
  //Array<int> table(LZW_TABLE_SIZE);  
  for (  phase=0; phase<2; phase++) {
	  curpos=0;
	//  printf("encode phase start %d\n",phase);
    read(src, START);//in->setpos( beginin);
	read(src, 1);
	//j=src[0];
	//printf(" encode codesize %d\n",j);
     bits=codesize+1,shift=0,buff=0;
     blocksize=0,maxcode=(1<<codesize)+1,last=-1;//,dict[4096];
    //Array<int> dict(4096);
    lzw_reset();
     end=false;
	// read(src, 1);
	// blocksize= src[0];
	 //printf("encode blocksize %d\n",blocksize);
	 //curpos++;
    while (read(src, 1)!=0 ) {//&&  curpos<len && end==false
		//read(src, 1);
		curpos++;
	 blocksize= src[0];// printf(" %d",blocksize);
      for (  i=0; i<blocksize; i++) {
		  readbytes=read(src, 1);curpos++;
		  if (readbytes==-1) printf("end of file");
	    buff=(buff|(src[0]<<shift));
		//if (buff<0) printf("buff < 0");
        shift=shift+8;
        while (shift>=bits && end==false) {
            code=buff&((1<<bits)-1);
			//if (phase==1) printf(" %d",code);
          buff=buff>>bits;
          shift=shift-bits;
          if (!bsize && code!=(1<<codesize)) {
            hdrsize=hdrsize+4;
            src[0]=0;src[1]=0;src[2]=0;src[3]=0;
			write(src,4);//out->put32(0);
          }
          if (!bsize) bsize=blocksize;
          if (code==(1<<codesize)) {
            if (maxcode>(1<<codesize)+1) {
              if (clearpos && clearpos!=69631-maxcode) return 0;
              clearpos=69631-maxcode;
            }
            bits=codesize+1, maxcode=(1<<codesize)+1, last=-1;
            lzw_reset();
          }
          else if (code==(1<<codesize)+1) end=true;
          else if (code>maxcode+1) return 0;
          else {
            j=(code<=maxcode?code:last),size=1;
            while (j>=(1<<codesize)) {
              output[4096-(size++)]=dict[j]&255;
              j=dict[j]>>8;
            }
            output[4096-size]=j;
            if (phase==1) write(output+(4096-size),size); else diffpos=diffpos+size;//out->blockwrite(&output[4096-size],  size  );
            if (code==maxcode+1) { 
			    if (phase==1) {
					src[0]=j;
					write(src,1);
					//out->putc(j); 
				} else {diffpos++; }
			}
            if (last!=-1) {
              if (++maxcode>=8191) return 0;
              if (maxcode<=4095)
              {
                key=(last<<8)+j, index=-1;
                lzw_find(key);
                dict[maxcode]=key;
                table[(index<0)?(0-index-1):offset]=maxcode;
                if (phase==0 && index>0) {
                    hdrsize=hdrsize+4;
                    j=diffpos-size-(code==maxcode);
					src[3]=j;src[2]=j>>8;src[1]=j>>16;src[0]=j>>24;
					printf ("Diff %d\n",j);
                    write(src,4);////out->put32(j);
                    diffpos=size+(code==maxcode);
                  }
                }
              //}
              if (maxcode>=((1<<bits)-1) && bits<12) bits++;
            }
            last=code;
          }
        }
      }
	  
	 //curpos++;
    }
  }
  //diffpos= out->curpos();
  write(src,START);//out->setpos(beginout);
  src[0]=hdrsize>>8;write(src,1);//out->putc(hdrsize>>8);
  src[0]=hdrsize&255;write(src,1);//out->putc(hdrsize&255);
  src[0]=255-bsize;write(src,1);//out->putc(255-bsize);
  src[0]=(clearpos>>8)&255;write(src,1);//out->putc((clearpos>>8)&255);
  src[0]=clearpos&255;write(src,1);//out->putc(clearpos&255);
  write(src,END);//out->setpos(diffpos);
  //return in->curpos()-beginin==len-1;
//  printf("Gif encode done\n");
}
int main() {
    int i;  
    if (!(dict = malloc(4096,sizeof(int)))) exit(-1);
    if (!(output = malloc(4096,sizeof(char)))) exit(-1);
	if (!(table = malloc(LZW_TABLE_SIZE,sizeof(int)))) exit(-1); 
	if (!(src = malloc(4,sizeof(char)))) exit(-1);
}
