// Model for 1 bit image data

// StateMapContext  SMC
// APM1 APM1
// APM2 APM2 //not used
// RunContextMap RCM
// SmallStationaryContextMap  SCM
// MContextMap MCM
// ContextMap CM
// Mixer MX
// SMC,APM1,APM2,RCM,SCM,MCM,CM,MX (1,2,3,4,5,6,7,8,9)
enum {SMC=1,APM1,APM2,RCM,SCM,MCM,CM,MX,MC};
int t[0x40000]={}; 
int r0,r1,r2,r3,N,w;
int cxt[11]={};  // contexts
int MAXLEN; // longest allowed match + 1
  int tm[0x100000]={};    // hash table of pointers to contexts
  int h;      // hash of last 7 bytes
  int ptr;    // points to next byte of match if any
  int len;    // length of match, or 0 if no match
  int mm1,mm3;
  int match;
  int min(int a, int b) {return a<b?a:b;}
int matchMod(int y,int bpos,int pos){ 
 int ilen;
 int mlen;
 int i,pr0; 
 
    if (match!=y) len=0;  //bit mismatch
    if (bpos==0){
        //update match
        h=(h*997*8+buf(1)+1)&0xfffff;  // update context hash
            if (len) len=len+len<MAXLEN, ++ptr;
            else {  // find match
                ptr=tm[h];
                if (ptr && (pos-ptr)<0x1000000)
                while (buf(len+1)==bufr(ptr-len-1) && len<MAXLEN) ++len;
            }
            tm[h]=pos;  // update hash table
            //result=;
            //    if (result>0 && !(result&0xfff)) printf("pos=%d len=%d ptr=%d\n", pos, len, ptr);
            ilen=ilog(len)<<2;
            mlen=min(len, 32)<<6;
            mm1=(squash(ilen)+squash(mlen))/2;
            mm3=(squash(0-ilen)+squash(0-mlen))/2;
			vmx(SCM, 0, pos);
    }
    // predict match
    if (len && buf(1)==bufr(ptr-1)){
        match=(bufr(ptr)>>(7-bpos))&1;
        if (match) { //1
            pr0=mm1;
        }else{
            pr0=mm3;
        }
    }else{
        pr0=2047;
    }
    mxa(0,stretch(pr0));
    return len;
  }
// update is called in VM after every bit
int update(int y,int c0,int bpos,int c4,int pos){ 
    int i;
	int ismatch;
    //mxa(0,256); //add to mixer(0)
    for (i=0; i<N; ++i)
    t[cxt[i]&0x3FFFF]=smn(t[cxt[i]&0x3FFFF]); //get next state
    // update the contexts (pixels surrounding the predicted one)
    r0=(r0<<1)+y;
    r1=(r1<<1)+((buf(w-1)>>(7-bpos))&1);
    r2=(r2<<1)+((buf(w+w-1)>>(7-bpos))&1);
    r3=(r3<<1)+((buf(w+w+w-1)>>(7-bpos))&1);
    cxt[0]=0x100|(r0&0x7)+((r1>>4)&0x38)+((r2>>3)&0xc0);
    cxt[1]=0x200|((r0&1)|((r1>>4)&0x3e)|((r2>>2)&0x40)|((r3>>1)&0x80));
    cxt[2]=0x300|((r0&0x3f)^(r1&0x3ffe)^((r2<<2)&0x7f00)^((r3<<5)&0xf800));
    cxt[3]=0x400|((r0&0x3e)^(r1&0x0c0c)^(r2&0xc800));
    cxt[4]=0x100|(((r1&0x30)^(r3&0x0c0c))|(r0&3));
    cxt[5]=0x800|(((!r0)&0x444)|(r1&0xC0C)|(r2&0xAE3)|(r3&0x51C));
    cxt[6]=0xC00|((r0&1)|((r1>>4)&0x1d)|((r2>>1)&0x60)|(r3&0xC0));
    cxt[7]=0x1000|(((r0>>4)&0x2AC)|(r1&0xA4)|(r2&0x349)|((!r3)&0x14D));
	//pr=0;
    for (i=0; i<N; ++i)   smp(i,t[cxt[i]&0x3FFFF],1023);
	ismatch=matchMod( y, bpos, pos); 
    mxc(0); //mix components into mixer(0)
    // set mixer(0) contexts 
    mxs(0, (r0&0x7)|((r1>>4)&0x38)|((r2>>3)&0xc0), 256);
    mxs(0, ((r1&0x30)^(r3&0x0c))|(r0&3),256);
    mxs(0, (r0&1)|((r1>>4)&0x3e)|((r2>>2)&0x40)|((r3>>1)&0x80), 256);
    mxs(0, (r0&0x3e)^((r1>>8)&0x0c)^((r2>>8)&0xc8),256);
	mxs(0, ilog(ismatch),256);
    return mxp(0);//apm(0,mxp(0),c0,7); //predict mixer(0)
}
//VM calls this after every image block
void block(int a,int b) { 
    w=a; //get block info, image width
}
// main is called only once after VM init.
int main() {
    vms( 8,0,0,0,1,0,0,1,0); //8 SMC,1 MX, 1 MC 
    vmi( SMC,0,256,0,0); //SMC(0), context size 256,0,mixer(0)
    vmi( SMC,1,256,0,0); //...
    vmi( SMC,2,256,0,0);
    vmi( SMC,3,256,0,0);
    vmi( SMC,4,256,0,0);
    vmi( SMC,5,256,0,0);
    vmi( SMC,6,256,0,0);
    vmi( SMC,7,256,0,0);
	vmi(SCM,0,17,0,0);
    vmi(MX,0,8*2+18+1+1+2,1280+256,5);  // mixer(0), 12 inputs, context size 1280, context sets 5
    r0=0,r1=0,r2=0,r3=0; 
    N=8;
	  match=h=ptr=len=0;
mm1=mm3=0;
MAXLEN=65534;
}